<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Parallelismus Demo</title>
    <style>
      body { font-family: sans-serif; padding: 1rem }
      select, button { margin: .5rem 0 }
      .words { margin-top: 1rem }
  .word-main { cursor: help; }
  .word-meta { color: #666; font-size: 0.9em; margin-left: .5rem }
  /* horizontal word chips */
  #words { display: flex; flex-wrap: wrap; gap: .5rem; list-style: none; padding: 0; margin: 0 }
  #words li { list-style: none }
  .word-box { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: .4rem .6rem; border-radius: 6px; background: #fafafa; border: 1px solid #eee; min-width: 4ch; text-align: center }
  .word-english { font-weight: 600; font-size: 1rem; color: #111 }
  .word-original { font-family: serif; font-size: .95rem; color: #333; margin-top: .15rem }
  .word-box.selectable { cursor: pointer }
  .word-box.selected { background: #e6f0ff; border-color: #9fc5ff; box-shadow: 0 1px 0 rgba(0,0,0,0.03) }
      /* tooltip */
      #word-tooltip { position: absolute; background: #fff; border: 1px solid #ccc; padding: .5rem; box-shadow: 0 2px 6px rgba(0,0,0,0.12); display: none; z-index: 1000; max-width: 40rem; white-space: pre-wrap }
    </style>
  </head>
  <body>
    <h1>Parallelismus</h1>
    <div>
      <label>Book</label>
      <select id="books"></select>
    </div>
    <div>
      <label>Chapter</label>
      <select id="chapters"></select>
    </div>
    <div>
      <label>Verse</label>
      <select id="verses"></select>
    </div>

    <div class="words">
      <h3>Words</h3>
      <ul id="words"></ul>
    </div>

    <div style="margin-top:1rem">
      <h3>Add relation</h3>
      <div>
  <input id="src" placeholder="source strong" />
  <input id="tgt" placeholder="target strong" />
  <!-- allow typing a new relation type or choosing from existing via datalist -->
  <input id="type" list="relation-types" placeholder="relation type (similar/opposite/...)" />
  <datalist id="relation-types"></datalist>
        <button id="addRel">Add</button>
      </div>
      <pre id="result"></pre>
    </div>

    <div style="margin-top:1rem">
      <h3>Relations</h3>
      <div>
        <input id="relations-strong" placeholder="strong id to inspect" />
        <button id="showRelations">Show relations</button>
      </div>
      <ul id="relations-list"></ul>
    </div>

    <script type="module">
      import * as api from './static/app.js';

      const booksEl = document.getElementById('books');
      const chaptersEl = document.getElementById('chapters');
      const versesEl = document.getElementById('verses');
      const wordsEl = document.getElementById('words');
      const resultEl = document.getElementById('result');

      async function loadBooks(){
        const books = await api.fetchBooks();
        console.log('books', books);
        booksEl.innerHTML = '';
        books.forEach(b => {
          const opt = document.createElement('option');
          opt.value = b.id; opt.textContent = b.name;
          booksEl.appendChild(opt);
        });
        if(books[0]) loadChapters(books[0].id);
      }

      // simple HTML escape to prevent injection in tooltip content
      function escapeHtml(str) {
        if (str == null) return '';
        return String(str).replace(/[&<>"]+/g, function(s) {
          switch (s) {
            case '&': return '&amp;';
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '"': return '&quot;';
            default: return '';
          }
        });
      }

      async function loadChapters(bookId){
        const chapters = await api.fetchChapters(bookId);
        chaptersEl.innerHTML = '';
        chapters.forEach(c => {
          const opt = document.createElement('option');
          opt.value = c.id; opt.textContent = c.number;
          chaptersEl.appendChild(opt);
        });
        if(chapters[0]) loadVerses(chapters[0].id);
      }

      async function loadVerses(chapterId){
        const verses = await api.fetchVerses(chapterId);
        versesEl.innerHTML = '';
        verses.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v.id; opt.textContent = v.number;
          versesEl.appendChild(opt);
        });
        if(verses[0]) loadWords(verses[0].id);
      }

      // Render words: show canonical original and translation from the verse context (verse_original, verse_translation)
      // and expose all originals/translations (all_originals, all_translations) on hover via the native title tooltip.
      async function loadWords(verseId){
        const words = await api.fetchWords(verseId);
        wordsEl.innerHTML = '';
        words.forEach(w => {
          const li = document.createElement('li');

            const canonicalOriginal = w.verse_original || '';
            const canonicalTranslation = w.verse_translation || '';

            // create a chip-like box with english on top and original below
            const box = document.createElement('div');
            box.className = 'word-box word-main';
            box.tabIndex = 0; // focusable for keyboard

            const top = document.createElement('div');
            top.className = 'word-english';
            top.textContent = canonicalTranslation || '';

            const bottom = document.createElement('div');
            bottom.className = 'word-original';
            bottom.textContent = canonicalOriginal || (canonicalTranslation ? '' : w.strong || '(no text)');

            // prepare full lists for custom tooltip
            const allOriginals = Array.isArray(w.all_originals) ? w.all_originals : [];
            const allTranslations = Array.isArray(w.all_translations) ? w.all_translations : [];
            box.dataset.allOriginals = JSON.stringify(allOriginals);
            box.dataset.allTranslations = JSON.stringify(allTranslations);
            // store the strong id on the chip for selection and relations
            box.dataset.strong = w.strong || '';

            // small link icon to open strong definition in new tab
            const strongLink = document.createElement('a');
            strongLink.href = '/strong/' + encodeURIComponent(w.strong);
            strongLink.target = '_blank';
            strongLink.textContent = 'ðŸ”—';
            strongLink.style.fontSize = '0.8rem';
            strongLink.style.marginTop = '0.25rem';
            strongLink.title = 'Open strong ' + w.strong;
            // clicking the link should not toggle chip selection
            strongLink.addEventListener('click', (e)=> e.stopPropagation());
            box.appendChild(strongLink);

            box.appendChild(top);
            box.appendChild(bottom);
            // allow click-to-select for relation creation
            box.classList.add('selectable');
            box.addEventListener('click', (ev) => {
              box.classList.toggle('selected');
              // fill src/tgt inputs depending on selections
              const selected = Array.from(document.querySelectorAll('.word-box.selected'));
              if (selected.length === 1) {
                document.getElementById('src').value = selected[0].dataset.strong || '';
              } else if (selected.length === 2) {
                document.getElementById('src').value = selected[0].dataset.strong || '';
                document.getElementById('tgt').value = selected[1].dataset.strong || '';
              }
            });
            li.appendChild(box);
            wordsEl.appendChild(li);
        });
      }

        // relations panel: fetch and show relations for a strong
        document.getElementById('showRelations').addEventListener('click', async ()=>{
          const strong = document.getElementById('relations-strong').value.trim();
          if (!strong) return;
          const groups = await api.fetchGroupedRelations(strong);
          const list = document.getElementById('relations-list');
          list.innerHTML = '';
          groups.forEach(g => {
            const li = document.createElement('li');
            const header = document.createElement('div');
            header.textContent = `${g.relation_type}: ${g.source_id} â†’ ${g.target_id}`;
            li.appendChild(header);

            if (g.source_verse_ids && g.source_verse_ids.length) {
              const versesContainer = document.createElement('div');
              versesContainer.style.marginTop = '.25rem';
              g.source_verse_ids.forEach(vid => {
                const btn = document.createElement('button');
                // show the requested label '(Source: Link)'
                btn.textContent = `(Source: Link) ${vid}`;
                btn.style.marginRight = '6px';
                btn.addEventListener('click', async ()=>{
                  // fetch verse, then navigate selects to the verse's chapter and verse
                  const verse = await api.fetchVerse(vid);
                  // load chapters for the book containing the verse's chapter
                  // we need to find the book id: fetch chapter to get book_id
                  const chap = await api.fetchChapter(verse.chapter_id);
                  // load chapters for the book then select the correct chapter and verse
                  await loadChapters(chap.book_id);
                  // give the browser a tick to render the new chapter options, then select
                  setTimeout(async ()=>{
                    chaptersEl.value = String(chap.id);
                    await loadVerses(chap.id);
                    // now select the verse
                    versesEl.value = String(verse.id);
                  }, 150);
                });
                versesContainer.appendChild(btn);
              });
              li.appendChild(versesContainer);
            }

            // Add a Remove button to delete the grouped relation entries
            const removeBtn = document.createElement('button');
            removeBtn.textContent = 'Remove';
            removeBtn.style.marginLeft = '8px';
            removeBtn.addEventListener('click', async ()=>{
              // ask for confirmation
              if (!confirm('Remove this relation group? This will delete matching relations individually.')) return;
              // We need to delete all matching relation rows for this group. The grouped endpoint doesn't return relation ids,
              // so fetch the full relations for the source word and find matching (source,target,type) tuples.
              try {
                const full = await api.fetchRelations(g.source_id);
                // find all relations matching this group
                const toDelete = full.filter(r => r.source_id === g.source_id && r.target_id === g.target_id && r.relation_type === g.relation_type);
                for (const r of toDelete) {
                  await api.deleteRelation(r.id);
                }
                // refresh the list
                document.getElementById('showRelations').click();
                // refresh relation types too
                await populateRelationTypes();
              } catch (err) {
                alert('Failed to remove relation(s): ' + String(err));
              }
            });
            li.appendChild(removeBtn);

            list.appendChild(li);
          });
        });

      // Custom tooltip element (single shared element)
      const tooltip = document.createElement('div');
      tooltip.id = 'word-tooltip';
      // make tooltip non-interactive so it doesn't steal mouse events
      tooltip.style.pointerEvents = 'none';
      document.body.appendChild(tooltip);

      /* tooltip layout styles: use a two-column grid for translations (left) and originals (right) */
      const tooltipStyle = document.createElement('style');
      tooltipStyle.textContent = `
        #word-tooltip .tooltip-grid { display: grid; grid-template-columns: 1fr 1fr; gap: .75rem; }
        #word-tooltip .tooltip-col { padding: 0; margin: 0 }
        #word-tooltip .tooltip-col h4 { margin: 0 0 .25rem 0; font-size: .95em }
        #word-tooltip .tooltip-col ul { margin: 0; padding-left: 1rem }
      `;
      document.head.appendChild(tooltipStyle);

      // Helper to position tooltip near the mouse and keep it on-screen
      function positionTooltip(x, y) {
        const pad = 8;
        const winW = window.innerWidth;
        const winH = window.innerHeight;
        const rect = tooltip.getBoundingClientRect();
        let left = x + pad;
        let top = y - rect.height / 2;
        // if overflowing right, place to the left of cursor
        if (left + rect.width + pad > winW) left = x - rect.width - pad;
        // if overflowing top/bottom, clamp
        if (top < pad) top = pad;
        if (top + rect.height + pad > winH) top = winH - rect.height - pad;
        tooltip.style.left = (window.scrollX + left) + 'px';
        tooltip.style.top = (window.scrollY + top) + 'px';
      }

      // Show/hide tooltip on mouseover/mouseout; follow mouse using mousemove
      let activeTarget = null;
      function handleMouseOver(ev) {
        const target = ev.target;
        if (target && target.classList && target.classList.contains('word-main')) {
          activeTarget = target;
          // build a two-column HTML representation
          let originals = [];
          let translations = [];
          try { originals = JSON.parse(target.dataset.allOriginals || '[]'); } catch(e) {}
          try { translations = JSON.parse(target.dataset.allTranslations || '[]'); } catch(e) {}
          const leftList = translations.length ? '<ul>' + translations.map(t => `<li>${escapeHtml(t)}</li>`).join('') + '</ul>' : '<div>-</div>';
          const rightList = originals.length ? '<ul>' + originals.map(o => `<li>${escapeHtml(o)}</li>`).join('') + '</ul>' : '<div>-</div>';
          tooltip.innerHTML = `<div class="tooltip-grid"><div class="tooltip-col"><h4>Translations</h4>${leftList}</div><div class="tooltip-col"><h4>Originals</h4>${rightList}</div></div>`;
          tooltip.style.display = 'block';
          // position immediately and then follow mouse
          positionTooltip(ev.clientX, ev.clientY);
          document.addEventListener('mousemove', handleMouseMove);
        }
      }
      function handleMouseOut(ev) {
        const target = ev.target;
        if (target && target.classList && target.classList.contains('word-main')) {
          activeTarget = null;
          tooltip.style.display = 'none';
          document.removeEventListener('mousemove', handleMouseMove);
        }
      }
      function handleMouseMove(ev) {
        if (!activeTarget) return;
        positionTooltip(ev.clientX, ev.clientY);
      }

      document.body.addEventListener('mouseover', handleMouseOver);
      document.body.addEventListener('mouseout', handleMouseOut);

      // also support keyboard focus for accessibility (show tooltip on focus)
      document.body.addEventListener('focusin', (ev) => {
        const target = ev.target;
        if (target && target.classList && target.classList.contains('word-main')) {
          let originals = [];
          let translations = [];
          try { originals = JSON.parse(target.dataset.allOriginals || '[]'); } catch(e) {}
          try { translations = JSON.parse(target.dataset.allTranslations || '[]'); } catch(e) {}
          const leftList = translations.length ? '<ul>' + translations.map(t => `<li>${escapeHtml(t)}</li>`).join('') + '</ul>' : '<div>-</div>';
          const rightList = originals.length ? '<ul>' + originals.map(o => `<li>${escapeHtml(o)}</li>`).join('') + '</ul>' : '<div>-</div>';
          tooltip.innerHTML = `<div class="tooltip-grid"><div class="tooltip-col"><h4>Translations</h4>${leftList}</div><div class="tooltip-col"><h4>Originals</h4>${rightList}</div></div>`;
          tooltip.style.display = 'block';
          const rect = target.getBoundingClientRect();
          positionTooltip(rect.right + 8, rect.top + rect.height / 2);
        }
      });
      document.body.addEventListener('focusout', (ev) => {
        const target = ev.target;
        if (target && target.classList && target.classList.contains('word-main')) {
          tooltip.style.display = 'none';
        }
      });

      booksEl.addEventListener('change', ()=> loadChapters(Number(booksEl.value)) );
      chaptersEl.addEventListener('change', ()=> loadVerses(Number(chaptersEl.value)) );
      versesEl.addEventListener('change', ()=> loadWords(Number(versesEl.value)) );

      document.getElementById('addRel').addEventListener('click', async ()=>{
        const srcEl = document.getElementById('src');
        const tgtEl = document.getElementById('tgt');
        const typeEl = document.getElementById('type');
        const src = srcEl && srcEl.value ? srcEl.value : '';
        const tgt = tgtEl && tgtEl.value ? tgtEl.value : '';
        const type = typeEl && typeEl.value ? typeEl.value.trim() : '';
        if (!src || !tgt) {
          resultEl.textContent = 'Please select source and target words (two chips)';
          return;
        }
        if (!type) {
          resultEl.textContent = 'Please enter or select a relation type';
          return;
        }
        const payload = { source_id: src, target_id: tgt, relation_type: type };
        // include currently selected verse as source_verse_id when available
        const verseId = Number(versesEl && versesEl.value ? versesEl.value : 0);
        if (verseId) payload.source_verse_id = verseId;
        try {
          const res = await api.addRelation(payload);
          resultEl.textContent = 'Relation added: ' + JSON.stringify(res);
          // refresh relation types so new type is available
          await populateRelationTypes();
          // clear selections and inputs
          document.querySelectorAll('.word-box.selected').forEach(el => el.classList.remove('selected'));
          srcEl.value = '';
          tgtEl.value = '';
          // keep the type in the field so user can reuse it
        } catch (err) {
          resultEl.textContent = 'Error adding relation: ' + String(err);
        }
      });

      loadBooks();
      // populate relation types
      async function populateRelationTypes(){
        const types = await api.fetchRelationTypes();
        const data = document.getElementById('relation-types');
        data.innerHTML = types.map(t=>`<option value="${t}"></option>`).join('');
      }
      populateRelationTypes();
    </script>
  </body>
</html>
