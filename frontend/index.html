<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Parallelismus Demo</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Noto+Serif:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/static/styles.css">
  <style>
      :root{
        --bg:#f7fafc; --card:#ffffff; --muted:#6b7280; --accent:#2563eb; --chip-bg:#f1f5f9; --radius:10px; --shadow: 0 6px 18px rgba(15,23,42,0.06);
      }
      html,body{height:100%;}
      body{font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; background:var(--bg); color:#0f172a; margin:0}
      .wrap{max-width:1100px;margin:28px auto;padding:20px}
      header{display:flex;align-items:center;gap:12px;margin-bottom:18px}
      h1{font-weight:600;margin:0;font-size:1.35rem}
      .controls{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:12px}
      select,input,button{padding:8px 10px;border-radius:8px;border:1px solid #e6edf3;background:#fff}
      button{cursor:pointer}
      .card{background:var(--card);border-radius:var(--radius);box-shadow:var(--shadow);padding:14px}
      .words{margin-top:12px}
      /* chips */
      #words{display:flex;flex-wrap:wrap;gap:.5rem;margin:0;padding:0}
      #words li{list-style:none}
      .word-box{display:flex;flex-direction:column;align-items:center;justify-content:center;padding:.45rem .6rem;border-radius:8px;background:var(--chip-bg);border:1px solid #e6eef7;min-width:4ch;text-align:center}
      .word-english{font-weight:600;color:#0f172a}
      .word-original{font-family: 'Noto Serif', serif;color:var(--muted);margin-top:.15rem;font-size:.95rem}
      .word-box.selected{outline:3px solid rgba(37,99,235,0.12);box-shadow:0 6px 14px rgba(37,99,235,0.06)}
      /* relations */
      #relations-list{margin:0;padding:0}
      #relations-list li{list-style:none;margin:8px 0}
      a{color:var(--accent);text-decoration:none}
      a:hover{text-decoration:underline}
      /* tooltip */
      #word-tooltip{border-radius:8px}
      /* chapter view */
      .verse-words { display: flex; flex-wrap: wrap; gap: .5rem; list-style: none; padding: 0; margin: 0 }
      .verse-words li { list-style: none; display: inline-flex }
      .chapter-view { display: block; width: 100%; }
      #words > .chapter-view { flex-basis: 100%; flex-grow: 0; }
      .chapter-view .verse-block { margin-bottom: 1rem; }
      .chapter-view .verse-block h4 { margin: .5rem 0 .25rem 0 }
      @media (max-width:720px){.wrap{padding:12px}}
    </style>
  </head>
  <body>
    <div class="wrap app-shell">
      <div class="main-column">
        <header>
          <h1>Parallelismus</h1>
          <div style="margin-left:auto;color:var(--muted)">Explore verses & relations</div>
        </header>
        <div class="card">
          <div class="controls">
            <div><label style="display:block;font-size:.85rem;color:var(--muted)">Book</label><select id="books"></select></div>
            <div><label style="display:block;font-size:.85rem;color:var(--muted)">Chapter</label><select id="chapters"></select></div>
            <div><label style="display:block;font-size:.85rem;color:var(--muted)">Verse</label><select id="verses"></select></div>
          </div>
          <div class="words">
            <h3 style="margin:.25rem 0 6px 0">Words</h3>
            <ul id="words"></ul>
          </div>
        </div>
      </div>

      <aside class="side-column">
        <div id="add-relation-panel" class="card" aria-label="Add relation panel">
          <h3 style="margin:0 0 8px 0">Add relation</h3>
          <div id="add-drop-hint" class="drop-hint">Drop a word here to fill source or target</div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:8px">
            <input id="src" placeholder="source strong" />
            <input id="tgt" placeholder="target strong" />
            <input id="type" list="relation-types" placeholder="relation type (similar/opposite/...)" />
            <datalist id="relation-types"></datalist>
            <button id="addRel">Add</button>
          </div>
          <pre id="result" style="margin-top:8px"></pre>
        </div>

        <div id="relations-panel" class="card" aria-label="Relations panel">
          <h3 style="margin:0 0 8px 0">Relations</h3>
          <div id="relations-drop-hint" class="drop-hint">Drop a word here to inspect relations</div>
          <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;margin-top:8px">
            <input id="relations-strong" placeholder="strong id to inspect" />
            <button id="showRelations">Show relations</button>
          </div>
          <ul id="relations-list"></ul>
        </div>
      </aside>
    </div>

    <script type="module">
      import * as api from '/static/app.js';

      const booksEl = document.getElementById('books');
      const chaptersEl = document.getElementById('chapters');
      const versesEl = document.getElementById('verses');
      const wordsEl = document.getElementById('words');
      const resultEl = document.getElementById('result');

      async function loadBooks(){
        const books = await api.fetchBooks();
        console.log('books', books);
        booksEl.innerHTML = '';
        books.forEach(b => {
          const opt = document.createElement('option');
          opt.value = b.id; opt.textContent = b.name;
          booksEl.appendChild(opt);
        });
        if(books[0]) loadChapters(books[0].id);
      }

      // simple HTML escape to prevent injection in tooltip content
      function escapeHtml(str) {
        if (str == null) return '';
        return String(str).replace(/[&<>"]+/g, function(s) {
          switch (s) {
            case '&': return '&amp;';
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '"': return '&quot;';
            default: return '';
          }
        });
      }

      // return up to n random unique samples from arr
      function sampleRandom(arr, n) {
        if (!Array.isArray(arr)) return [];
        const len = arr.length;
        if (len <= n) return arr.slice();
        const out = [];
        const seen = new Set();
        while (out.length < n) {
          const i = Math.floor(Math.random() * len);
          if (!seen.has(i)) { seen.add(i); out.push(arr[i]); }
        }
        return out;
      }

      async function loadChapters(bookId){
        const chapters = await api.fetchChapters(bookId);
        chaptersEl.innerHTML = '';
        chapters.forEach(c => {
          const opt = document.createElement('option');
          opt.value = c.id; opt.textContent = c.number;
          chaptersEl.appendChild(opt);
        });
        if(chapters[0]) loadVerses(chapters[0].id);
      }

      async function loadVerses(chapterId, opts = { selectVerseId: null, showWholeChapter: false }){
        const verses = await api.fetchVerses(chapterId);
        versesEl.innerHTML = '';
        verses.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v.id; opt.textContent = v.number;
          versesEl.appendChild(opt);
        });
        // if a specific verse was requested, select it and load words for it
        if (opts.selectVerseId) {
          versesEl.value = String(opts.selectVerseId);
          await loadWords(Number(opts.selectVerseId));
          return;
        }
        // if we should show the whole chapter, fetch words for each verse and render grouped
        if (opts.showWholeChapter) {
          // clear words container and create a full-width chapter container
          wordsEl.innerHTML = '';
          const chapterContainer = document.createElement('div');
          chapterContainer.className = 'chapter-view';
          wordsEl.appendChild(chapterContainer);
          // Parallelize fetching all verses' words for faster chapter rendering
          const verseBlocks = verses.map(v => {
            const verseBlock = document.createElement('div');
            verseBlock.className = 'verse-block';
            const header = document.createElement('h4');
            const link = document.createElement('a');
            link.href = `/verse/${v.id}`;
            link.textContent = `Verse ${v.number}`;
            link.addEventListener('click', async (e) => {
              e.preventDefault();
              // focus this verse only
              await loadVerses(chapterId, { selectVerseId: v.id, showWholeChapter: false });
              history.pushState({}, '', `/verse/${v.id}`);
            });
            header.appendChild(link);
            verseBlock.appendChild(header);
            const wrapper = document.createElement('div');
            wrapper.id = `verse-${v.id}`;
            verseBlock.appendChild(wrapper);
            chapterContainer.appendChild(verseBlock);
            return { id: v.id, wrapper };
          });

          // fetch all verses' words in parallel
            await Promise.all(verseBlocks.map(async vb => {
            const words = await api.fetchWords(vb.id);
            const ul = document.createElement('ul');
            ul.className = 'verse-words';
            words.forEach(w => {
              const li = document.createElement('li');
              const canonicalOriginal = w.verse_original || '';
              const canonicalTranslation = w.verse_translation || '';
              const box = document.createElement('div');
              box.className = 'word-box word-main';
              box.tabIndex = 0;
                // make chip draggable in chapter-view as well
                box.setAttribute('draggable', 'true');
                box.addEventListener('dragstart', (e) => {
                  try { e.dataTransfer.setData('text/plain', w.strong || ''); } catch (err) {}
                  // mark drag start time so click immediately after a drag won't navigate
                  box.dataset.draggedAt = String(Date.now());
                  box.classList.add('dragging');
                });
                box.addEventListener('dragend', (e) => {
                  // keep a short grace window so click handlers can detect a recent drag
                  setTimeout(() => {
                    box.classList.remove('dragging');
                    box.dataset.draggedAt = '';
                  }, 50);
                });
              const top = document.createElement('div');
              top.className = 'word-english';
              top.textContent = canonicalTranslation || '';
              const bottom = document.createElement('div');
              bottom.className = 'word-original';
              bottom.textContent = canonicalOriginal || (canonicalTranslation ? '' : w.strong || '(no text)');
              box.dataset.allOriginals = JSON.stringify(Array.isArray(w.all_originals) ? w.all_originals : []);
              box.dataset.allTranslations = JSON.stringify(Array.isArray(w.all_translations) ? w.all_translations : []);
              box.dataset.strong = w.strong || '';
              // clicking the chip should open the strong page; dragging still works
              box.appendChild(top);
              box.appendChild(bottom);
              box.classList.add('selectable', 'word-main');
              // keyboard accessibility & ARIA
              box.setAttribute('role', 'button');
              box.setAttribute('aria-label', (canonicalTranslation || canonicalOriginal || w.strong) + ' — strong ' + (w.strong || ''));
              box.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter') {
                  window.open('/strong/' + encodeURIComponent(w.strong), '_blank');
                } else if (ev.key === ' ') {
                  ev.preventDefault();
                  box.classList.toggle('selected');
                  const selected = Array.from(document.querySelectorAll('.word-box.selected'));
                  if (selected.length === 1) {
                    document.getElementById('src').value = selected[0].dataset.strong || '';
                  } else if (selected.length === 2) {
                    document.getElementById('src').value = selected[0].dataset.strong || '';
                    document.getElementById('tgt').value = selected[1].dataset.strong || '';
                  }
                }
              });
              box.addEventListener('click', (ev) => {
                const draggedAt = Number(box.dataset.draggedAt || 0);
                if (draggedAt && (Date.now() - draggedAt) < 300) return;
                window.open('/strong/' + encodeURIComponent(w.strong), '_blank');
              });
              li.appendChild(box);
              ul.appendChild(li);
            });
            vb.wrapper.appendChild(ul);
          }));
          return;
        }
        // default: just load the first verse
        if(verses[0]) loadWords(verses[0].id);
      }

      // Render words: show canonical original and translation from the verse context (verse_original, verse_translation)
      // and expose all originals/translations (all_originals, all_translations) on hover via the native title tooltip.
      async function loadWords(verseId){
        const words = await api.fetchWords(verseId);
        wordsEl.innerHTML = '';
        words.forEach(w => {
          const li = document.createElement('li');

            const canonicalOriginal = w.verse_original || '';
            const canonicalTranslation = w.verse_translation || '';

            // create a chip-like box with english on top and original below
            const box = document.createElement('div');
            box.className = 'word-box word-main';
            box.tabIndex = 0; // focusable for keyboard

            const top = document.createElement('div');
            top.className = 'word-english';
            top.textContent = canonicalTranslation || '';

            const bottom = document.createElement('div');
            bottom.className = 'word-original';
            bottom.textContent = canonicalOriginal || (canonicalTranslation ? '' : w.strong || '(no text)');

            // prepare full lists for custom tooltip
            const allOriginals = Array.isArray(w.all_originals) ? w.all_originals : [];
            const allTranslations = Array.isArray(w.all_translations) ? w.all_translations : [];
            box.dataset.allOriginals = JSON.stringify(allOriginals);
            box.dataset.allTranslations = JSON.stringify(allTranslations);
            // store the strong id on the chip for selection and relations
            box.dataset.strong = w.strong || '';

            box.appendChild(top);
            box.appendChild(bottom);
            // allow click to open strong, drag to insert; mark as word-main for tooltip
            box.classList.add('selectable', 'word-main');
            // accessibility: ARIA role and keyboard handlers
            box.setAttribute('role', 'button');
            box.setAttribute('aria-label', (canonicalTranslation || canonicalOriginal || w.strong) + ' — strong ' + (w.strong || ''));
            box.addEventListener('keydown', (ev) => {
              if (ev.key === 'Enter') {
                window.open('/strong/' + encodeURIComponent(w.strong), '_blank');
              } else if (ev.key === ' ') {
                ev.preventDefault();
                box.classList.toggle('selected');
                const selected = Array.from(document.querySelectorAll('.word-box.selected'));
                if (selected.length === 1) {
                  document.getElementById('src').value = selected[0].dataset.strong || '';
                } else if (selected.length === 2) {
                  document.getElementById('src').value = selected[0].dataset.strong || '';
                  document.getElementById('tgt').value = selected[1].dataset.strong || '';
                }
              }
            });
            // make chip draggable with a small drag-timestamp guard to distinguish drag vs click
            box.setAttribute('draggable', 'true');
            box.addEventListener('dragstart', (e) => {
              try { e.dataTransfer.setData('text/plain', w.strong || ''); } catch (err) {}
              box.dataset.draggedAt = String(Date.now());
              box.classList.add('dragging');
            });
            box.addEventListener('dragend', (e) => {
              setTimeout(() => { box.classList.remove('dragging'); box.dataset.draggedAt = ''; }, 50);
            });
            box.addEventListener('click', (ev) => {
              const draggedAt = Number(box.dataset.draggedAt || 0);
              if (draggedAt && (Date.now() - draggedAt) < 300) return;
              window.open('/strong/' + encodeURIComponent(w.strong), '_blank');
            });
            li.appendChild(box);
            wordsEl.appendChild(li);
        });
      }

          // Add drop handlers for side panels
          const addPanel = document.getElementById('add-relation-panel');
          const addHint = document.getElementById('add-drop-hint');
          const relationsPanel = document.getElementById('relations-panel');
          const relationsHint = document.getElementById('relations-drop-hint');

          function allowDrop(ev){ ev.preventDefault(); }
          function handleAddDrop(ev){
            ev.preventDefault();
            const strong = ev.dataTransfer.getData('text/plain');
            if (!strong) return;
            // Prefer the input actually under the drop point (so dropping onto the tgt input writes tgt).
            const srcEl = document.getElementById('src');
            const tgtEl = document.getElementById('tgt');
            let handled = false;
            try {
              const el = document.elementFromPoint(ev.clientX, ev.clientY);
              const inp = el && el.closest ? el.closest('input') : null;
              if (inp === tgtEl) { tgtEl.value = strong; handled = true; }
              else if (inp === srcEl) { srcEl.value = strong; handled = true; }
            } catch (e) {}
            if (!handled) {
              // Prefer the currently focused input (src/tgt) and overwrite it; otherwise overwrite src
              const active = document.activeElement;
              if (active === tgtEl || active === srcEl) {
                active.value = strong;
              } else {
                // overwrite src by default
                srcEl.value = strong;
              }
            }
            // small flash
            addPanel.classList.add('drop-target');
            setTimeout(()=>addPanel.classList.remove('drop-target'), 350);
          }

          function handleRelationsDrop(ev){
            ev.preventDefault();
            const strong = ev.dataTransfer.getData('text/plain');
            if (!strong) return;
            document.getElementById('relations-strong').value = strong;
            // trigger show relations
            document.getElementById('showRelations').click();
            relationsPanel.classList.add('drop-target');
            setTimeout(()=>relationsPanel.classList.remove('drop-target'), 350);
          }

          addPanel.addEventListener('dragover', allowDrop);
          addPanel.addEventListener('drop', handleAddDrop);
          relationsPanel.addEventListener('dragover', allowDrop);
          relationsPanel.addEventListener('drop', handleRelationsDrop);

        // relations panel: fetch and show relations for a strong
        document.getElementById('showRelations').addEventListener('click', async ()=>{
          const strong = document.getElementById('relations-strong').value.trim();
          if (!strong) return;
          const groups = await api.fetchGroupedRelations(strong);
          const list = document.getElementById('relations-list');
          list.innerHTML = '';
          groups.forEach(g => {
            const li = document.createElement('li');
            const header = document.createElement('div');
            header.textContent = `${g.relation_type}: ${g.source_id} → ${g.target_id}`;
            li.appendChild(header);

            if (g.source_verse_ids && g.source_verse_ids.length) {
              const versesContainer = document.createElement('div');
              versesContainer.style.marginTop = '.25rem';
              g.source_verse_ids.forEach(vid => {
                const btn = document.createElement('button');
                // show the requested label '(Source: Link)'
                btn.textContent = `(Source: Link) ${vid}`;
                btn.style.marginRight = '6px';
                btn.addEventListener('click', async ()=>{
                  // fetch verse, then navigate selects to the verse's chapter and verse
                  const verse = await api.fetchVerse(vid);
                  // load chapters for the book containing the verse's chapter
                  // we need to find the book id: fetch chapter to get book_id
                  const chap = await api.fetchChapter(verse.chapter_id);
                  // load chapters for the book then select the correct chapter and verse
                  await loadChapters(chap.book_id);
                  // give the browser a tick to render the new chapter options, then select
                  setTimeout(async ()=>{
                    chaptersEl.value = String(chap.id);
                    await loadVerses(chap.id);
                    // now select the verse
                    versesEl.value = String(verse.id);
                  }, 150);
                });
                versesContainer.appendChild(btn);
              });
              li.appendChild(versesContainer);
            }

            // Add a Remove button to delete the grouped relation entries
            const removeBtn = document.createElement('button');
            removeBtn.textContent = 'Remove';
            removeBtn.style.marginLeft = '8px';
            removeBtn.addEventListener('click', async ()=>{
              // ask for confirmation
              if (!confirm('Remove this relation group? This will delete matching relations individually.')) return;
              // We need to delete all matching relation rows for this group. The grouped endpoint doesn't return relation ids,
              // so fetch the full relations for the source word and find matching (source,target,type) tuples.
              try {
                const full = await api.fetchRelations(g.source_id);
                // find all relations matching this group
                const toDelete = full.filter(r => r.source_id === g.source_id && r.target_id === g.target_id && r.relation_type === g.relation_type);
                for (const r of toDelete) {
                  await api.deleteRelation(r.id);
                }
                // refresh the list
                document.getElementById('showRelations').click();
                // refresh relation types too
                await populateRelationTypes();
              } catch (err) {
                alert('Failed to remove relation(s): ' + String(err));
              }
            });
            li.appendChild(removeBtn);

            list.appendChild(li);
          });
        });

      // Custom tooltip element (single shared element)
      const tooltip = document.createElement('div');
      tooltip.id = 'word-tooltip';
      // make tooltip non-interactive so it doesn't steal mouse events
      tooltip.style.pointerEvents = 'none';
      document.body.appendChild(tooltip);

      /* tooltip layout styles: use a two-column grid for translations (left) and originals (right) */
      const tooltipStyle = document.createElement('style');
      tooltipStyle.textContent = `
        #word-tooltip .tooltip-grid { display: grid; grid-template-columns: 1fr 1fr; gap: .75rem; }
        #word-tooltip .tooltip-col { padding: 0; margin: 0 }
        #word-tooltip .tooltip-col h4 { margin: 0 0 .25rem 0; font-size: .95em }
        #word-tooltip .tooltip-col ul { margin: 0; padding-left: 1rem }
      `;
      document.head.appendChild(tooltipStyle);

      // Helper to position tooltip anchored at the bottom-center of the main content column
      const mainColumn = document.querySelector('.main-column');
      function positionTooltipBottom() {
        try {
          const colRect = mainColumn.getBoundingClientRect();
          const tw = tooltip.getBoundingClientRect();
          // center horizontally within main column
          let left = Math.round(colRect.left + (colRect.width - tw.width) / 2);
          if (left < 8) left = 8;
          if (left + tw.width + 8 > window.innerWidth) left = Math.max(8, window.innerWidth - tw.width - 8);
          // place slightly above the bottom of the main column
          let top = Math.round(colRect.bottom - tw.height - 12);
          if (top < 8) top = 8;
          tooltip.style.left = (window.scrollX + left) + 'px';
          tooltip.style.top = (window.scrollY + top) + 'px';
        } catch (e) {
          // fallback to bottom of viewport
          const tw = tooltip.getBoundingClientRect();
          const left = Math.max(8, Math.round((window.innerWidth - tw.width) / 2));
          const top = Math.max(8, Math.round(window.innerHeight - tw.height - 20));
          tooltip.style.left = left + 'px';
          tooltip.style.top = (window.scrollY + top) + 'px';
        }
      }

      // Show/hide tooltip on mouseover/mouseout; follow mouse using mousemove
      let activeTarget = null;
      function handleMouseOver(ev) {
        const target = ev.target.closest ? ev.target.closest('.word-main') : ev.target;
        if (target) {
          activeTarget = target;
          // build a two-column HTML representation
          let originals = [];
          let translations = [];
          try { originals = JSON.parse(target.dataset.allOriginals || '[]'); } catch(e) {}
          try { translations = JSON.parse(target.dataset.allTranslations || '[]'); } catch(e) {}
          // sample up to 10 random items to avoid overflow
          const sampledTranslations = sampleRandom(translations, 10);
          const sampledOriginals = sampleRandom(originals, 10);
          const leftList = sampledTranslations.length ? '<ul>' + sampledTranslations.map(t => `<li>${escapeHtml(t)}</li>`).join('') + '</ul>' : '<div>-</div>';
          const rightList = sampledOriginals.length ? '<ul>' + sampledOriginals.map(o => `<li>${escapeHtml(o)}</li>`).join('') + '</ul>' : '<div>-</div>';
          tooltip.innerHTML = `<div class="tooltip-grid"><div class="tooltip-col"><h4>Translations</h4>${leftList}</div><div class="tooltip-col"><h4>Originals</h4>${rightList}</div></div>`;
          tooltip.classList.add('show');
          // position anchored at bottom of main column (stop following mouse)
          positionTooltipBottom();
        }
      }
      function handleMouseOut(ev) {
        // if the mouse moved to another element that's still inside the same word-main, don't hide
        const from = ev.target;
        const to = ev.relatedTarget;
        const fromRoot = from && from.closest ? from.closest('.word-main') : null;
        const toRoot = to && to.closest ? to.closest('.word-main') : null;
        if (fromRoot && fromRoot === toRoot) return; // still inside the same chip
        if (fromRoot) {
          activeTarget = null;
          tooltip.classList.remove('show');
        }
      }
  document.body.addEventListener('mouseover', handleMouseOver);
  document.body.addEventListener('mouseout', handleMouseOut);

  // Reposition tooltip on scroll/resize when visible so it stays anchored to the main column
  window.addEventListener('scroll', () => { if (tooltip.classList.contains('show')) positionTooltipBottom(); }, { passive: true });
  window.addEventListener('resize', () => { if (tooltip.classList.contains('show')) positionTooltipBottom(); });

      // also support keyboard focus for accessibility (show tooltip on focus)
      document.body.addEventListener('focusin', (ev) => {
        const target = ev.target;
        if (target && target.classList && target.classList.contains('word-main')) {
          let originals = [];
          let translations = [];
          try { originals = JSON.parse(target.dataset.allOriginals || '[]'); } catch(e) {}
          try { translations = JSON.parse(target.dataset.allTranslations || '[]'); } catch(e) {}
          const leftList = translations.length ? '<ul>' + translations.map(t => `<li>${escapeHtml(t)}</li>`).join('') + '</ul>' : '<div>-</div>';
          const rightList = originals.length ? '<ul>' + originals.map(o => `<li>${escapeHtml(o)}</li>`).join('') + '</ul>' : '<div>-</div>';
          tooltip.innerHTML = `<div class="tooltip-grid"><div class="tooltip-col"><h4>Translations</h4>${leftList}</div><div class="tooltip-col"><h4>Originals</h4>${rightList}</div></div>`;
          tooltip.classList.add('show');
          positionTooltipBottom();
        }
      });
      document.body.addEventListener('focusout', (ev) => {
        const target = ev.target;
        if (target && target.classList && target.classList.contains('word-main')) {
          tooltip.classList.remove('show');
        }
      });

      // When the user selects chapter/verse, update the URL to the simplified format
      chaptersEl.addEventListener('change', async ()=> {
        const chapterId = Number(chaptersEl.value);
        // update verses and default URL to chapter view
        await loadVerses(chapterId, { selectVerseId: null, showWholeChapter: true });
        const newUrl = `/chapter/${chapterId}`;
        history.pushState({}, '', newUrl);
      });

      versesEl.addEventListener('change', async ()=> {
        const verseId = Number(versesEl.value);
        const chapterId = Number(chaptersEl.value);
        // update words for the verse and push URL including verse
        await loadWords(verseId);
        const newUrl = `/verse/${verseId}`;
        history.pushState({}, '', newUrl);
      });

      // handle back/forward navigation
      window.addEventListener('popstate', (ev) => {
        // re-init view from current path
        initFromPath();
      });

      document.getElementById('addRel').addEventListener('click', async ()=>{
        const srcEl = document.getElementById('src');
        const tgtEl = document.getElementById('tgt');
        const typeEl = document.getElementById('type');
        const src = srcEl && srcEl.value ? srcEl.value : '';
        const tgt = tgtEl && tgtEl.value ? tgtEl.value : '';
        const type = typeEl && typeEl.value ? typeEl.value.trim() : '';
        if (!src || !tgt) {
          resultEl.textContent = 'Please select source and target words (two chips)';
          return;
        }
        if (!type) {
          resultEl.textContent = 'Please enter or select a relation type';
          return;
        }
        const payload = { source_id: src, target_id: tgt, relation_type: type };
        // include currently selected verse as source_verse_id when available
        const verseId = Number(versesEl && versesEl.value ? versesEl.value : 0);
        if (verseId) payload.source_verse_id = verseId;
        try {
          const res = await api.addRelation(payload);
          resultEl.textContent = 'Relation added: ' + JSON.stringify(res);
          // refresh relation types so new type is available
          await populateRelationTypes();
          // clear selections and inputs
          document.querySelectorAll('.word-box.selected').forEach(el => el.classList.remove('selected'));
          srcEl.value = '';
          tgtEl.value = '';
          // keep the type in the field so user can reuse it
        } catch (err) {
          resultEl.textContent = 'Error adding relation: ' + String(err);
        }
      });

      // parse URL path for /chapter/{chapter_id} or /verse/{verse_id}
      function parsePath() {
        const parts = window.location.pathname.split('/').filter(Boolean);
        const result = { chapterId: null, verseId: null };
        if (parts.length >= 2 && parts[0] === 'chapter') {
          result.chapterId = Number(parts[1]);
        } else if (parts.length >= 2 && parts[0] === 'verse') {
          result.verseId = Number(parts[1]);
        }
        return result;
      }

      async function initFromPath() {
        const path = parsePath();
        if (!path.chapterId && !path.verseId) {
          // normal entry: load books so user can pick
          await loadBooks();
          return;
        }
        if (path.chapterId) {
          // fetch chapter to find its book, then load chapters for that book
          const chapter = await api.fetchChapter(path.chapterId);
          const books = await api.fetchBooks();
          booksEl.innerHTML = '';
          books.forEach(b => { const opt = document.createElement('option'); opt.value = b.id; opt.textContent = b.name; booksEl.appendChild(opt); });
          booksEl.value = String(chapter.book_id);
          const chapters = await api.fetchChapters(chapter.book_id);
          chaptersEl.innerHTML = '';
          chapters.forEach(c => { const opt = document.createElement('option'); opt.value = c.id; opt.textContent = c.number; chaptersEl.appendChild(opt); });
          chaptersEl.value = String(path.chapterId);
          await loadVerses(path.chapterId, { selectVerseId: null, showWholeChapter: true });
          return;
        }
        // if we have a verse id, fetch the verse to get its chapter, then select the chapter and verse
        if (path.verseId) {
          const verse = await api.fetchVerse(path.verseId);
          const chap = await api.fetchChapter(verse.chapter_id);
          const books = await api.fetchBooks();
          booksEl.innerHTML = '';
          books.forEach(b => { const opt = document.createElement('option'); opt.value = b.id; opt.textContent = b.name; booksEl.appendChild(opt); });
          booksEl.value = String(chap.book_id);
          const chapters = await api.fetchChapters(chap.book_id);
          chaptersEl.innerHTML = '';
          chapters.forEach(c => { const opt = document.createElement('option'); opt.value = c.id; opt.textContent = c.number; chaptersEl.appendChild(opt); });
          chaptersEl.value = String(chap.id);
          await loadVerses(chap.id, { selectVerseId: path.verseId, showWholeChapter: false });
          return;
        }
      }

      initFromPath();
      // populate relation types
      async function populateRelationTypes(){
        const types = await api.fetchRelationTypes();
        const data = document.getElementById('relation-types');
        data.innerHTML = types.map(t=>`<option value="${t}"></option>`).join('');
      }
      populateRelationTypes();
    </script>
  </body>
</html>
